---
title: "Use cases"
id: "metadata-use-case-guides"
---

The Metadata API serves two primary functions:

1. You can use it for [ad-hoc GraphQL queries](/docs/dbt-cloud-apis-access-metadata-api) to explore your dbt project and diagnose its performance

2. It can share metadata generated by your dbt project and its execution with other tools in your stack, allowing users in your organization to:
    - Discover tables, columns, and associated metadata (like column definitions or data lineage) outside of dbt Cloud
    - Use BI platforms to query business metrics that you define and govern centrally in the [dbt Semantic Layer](/docs/use-dbt-semantic-layer/dbt-semantic-layer)
    - Add [quality status tiles](/docs/deploy/dashboard-status-tiles#setup) to BI dashboards, to signal the freshness and accuracy of underlying data in real-time
    - Monitor for data SLA compliance and get notifications for run completions or failures
    - Diagnose and improve the performance of your dbt deployment

The Metadata API is categorized into three use cases*:

- Discover
- Quality
- Operations

*_Additional use case and integration guides are coming soon_.

## Discovery

The Metadata API empowers users to find and understand data for analysis. [Integrated tools](https://www.getdbt.com/product/integrations/) enable users to analyze dbt assets like models and metrics to analyze, including via Semantic Layer queries.

Data producers need to be able to govern and organize information for their stakeholders and know what’s already defined. Meanwhile, data consumers must analyze data quickly and confidently at scale, often self-serve to inform decisions that improve business outcomes and reduce organizational overhead and load on the data team.

The Metadata API can be leveraged for discovery experiences in data catalogs, BI/analytics, data apps, and generative ML tools.

<Lightbox src="/img/docs/dbt-cloud/metadata-api/dbt-dag.jpg" title="Data lineage produced by dbt"/>

### Data catalog

The Metadata API lets users access the definitions and statuses of [models](/docs/build/models), metrics, and sources from the dbt project. Rich context like column names and descriptions are valuable for data consumers to understand what the data mean and what’s worth analyzing. Descriptive metadata can also be used for machine learning algorithms.

*Note: To access catalog info like columns, docs must be [generated](/docs/collaborate/build-and-view-your-docs#set-up-a-documentation-job) in the job being queried.*

<Tabs>

<TabItem value="querydatacatalog" label="Example query">

```
models(jobId: $jobId) {
    name
    uniqueId
    type
    description
    columns {
      name
      description
      type
    }
    status
    runGeneratedAt
    compiledSql
    owner
  }

```

</TabItem>

<TabItem value="responsedatacatalog" label="Example response">

 ```
 {
        "name": "customers",
        "uniqueId": "model.demo_data.customers",
        "type": "BASE TABLE",
        "description": "Customer overview data mart, offering key details for each unique customer. One row per customer.",
        "owner": "John Smith"
        "columns": [
          {
            "name": "CUSTOMER_ID",
            "description": "The unique key of the orders mart.",
            "type": "TEXT"
          },
          {
            "name": "CUSTOMER_NAME",
            "description": "Customers' full name.",
            "type": "TEXT"
          },
          {
            "name": "COUNT_LIFETIME_ORDERS",
            "description": "Total number of orders a customer has ever placed.",
            "type": "NUMBER"
          },
          {
            "name": "LIFETIME_SPEND",
            "description": "The sum of all the order totals (including tax) that a customer has ever placed.",
            "type": "FLOAT"
          },
          {
            "name": "CUSTOMER_TYPE",
            "description": "Options are 'new' or 'returning', indicating if a customer has ordered more than once or has only placed their first order to date.",
            "type": "TEXT"
          }
        ],
        "status": "success",
        "runGeneratedAt": "2023-02-24T18:02:06.551Z",
        "compiledSql": "with customers as select * from analytics.semantic_layer_demo.stg_customers ... select * from joined",
}
 ```

</TabItem>
</Tabs>


### Query dbt Metrics

Tools integrated with the dbt Semantic Layer import [metric](/docs/build/metrics) definitions with the time grain and dimensions so their users can query them. The Metadata API provides context about the metrics to power these user experiences. See the [dbt Semantic Layer integration guide](/guides/dbt-ecosystem/sl-partner-integration-guide) for more information about how to action these queries.

<Tabs>

<TabItem value="querymetrics" label="Example query">

```
metrics(jobId: $jobId) {
    name
    description
    dependsOn
    calculation_method
    expression
    dimensions
    timeGrains
  }
  ```
</TabItem>

<TabItem value="responsemetrics" label="Example response">

```
{
        "name": "expenses",
        "description": "Total expenses per order",
        "dependsOn": [
          "model.demo_data.orders"
        ],
        "calculation_method": "sum",
        "expression": "order_cost",
        "dimensions": [
          "location_name",
          "is_first_order"
        ],
        "timeGrains": [
          "week",
          "month",
        ]
}
```
</TabItem>

</Tabs>

### Project lineage

Users can generate a project [graph](/terms/data-lineage) to understand lineage in catalogs and development tools to discover existing objects, trace the root causes of issues, or understand the impacts of changes to dbt project nodes. While the dbt Docs also provide a lineage graph, the API enables custom solutions. It provides information to traverse the DAG by working downstream via children or tracing upstream dependencies (`dependsOn` and `parents…`, as in the example below), which provides the flexibility to suit user needs in a native experience. 

*Note: Column-level lineage is not currently supported and usage of downstream tools like dashboards needs to be manually added as [exposures](/docs/build/exposures).*

<Tabs>

<TabItem value="querylineage" label="Example query">

```
query Lineage($jobId: Int!) {
  sources(jobId: $jobId) {
    uniqueId
  }
  models(jobId: $jobId) {
    uniqueId
    dependsOn
    parentsModels {
      uniqueId
      dependsOn
    }
    parentsSources {
      uniqueId
    }
  }
  metrics(jobId: $jobId) {
    uniqueId
    dependsOn
    model {
      uniqueId
      dependsOn
    }
  }
}
```

</TabItem>

<TabItem value="responselineage" label="Example response">

```
"sources": [
      {
        "name": "customers",
        "uniqueId": "source.demo_data.ecommerce.customers"
      },
      {
        "name": "locations",
        "uniqueId": "source.demo_data.ecommerce.locations"
      },
      {
        "name": "order_items",
        "uniqueId": "source.demo_data.ecommerce.order_items"
      },
      {
        "name": "orders",
        "uniqueId": "source.demo_data.ecommerce.orders"
      },
      {
        "name": "products",
        "uniqueId": "source.demo_data.ecommerce.products"
      },
      {
        "name": "supplies",
        "uniqueId": "source.demo_data.ecommerce.supplies"
      }
    ],
    "models": [
      {
        "name": "customers",
        "uniqueId": "model.demo_data.customers",
        "dependsOn": [
          "model.demo_data.stg_customers",
          "model.demo_data.orders"
        ],
        "parentsModels": [
          {
            "name": "orders",
            "uniqueId": "model.demo_data.orders",
            "dependsOn": [
              "model.demo_data.stg_orders",
              "model.demo_data.stg_order_items",
              "model.demo_data.stg_products",
              "model.demo_data.stg_locations",
              "model.demo_data.stg_supplies"
            ]
          },
          {
            "name": "stg_customers",
            "uniqueId": "model.demo_data.stg_customers",
            "dependsOn": [
              "source.demo_data.ecommerce.customers"
            ]
          },
          {
            "name": "stg_locations",
            "uniqueId": "model.demo_data.stg_locations",
            "dependsOn": [
              "source.demo_data.ecommerce.locations",
              "macro.dbt_utils.current_timestamp"
            ]
          },
          {
            "name": "stg_order_items",
            "uniqueId": "model.demo_data.stg_order_items",
            "dependsOn": [
              "source.demo_data.ecommerce.order_items"
            ]
          },
          {
            "name": "stg_orders",
            "uniqueId": "model.demo_data.stg_orders",
            "dependsOn": [
              "source.demo_data.ecommerce.orders",
              "macro.dbt_utils.current_timestamp"
            ]
          },
          {
            "name": "stg_products",
            "uniqueId": "model.demo_data.stg_products",
            "dependsOn": [
              "source.demo_data.ecommerce.products"
            ]
          },
          {
            "name": "stg_supplies",
            "uniqueId": "model.demo_data.stg_supplies",
            "dependsOn": [
              "source.demo_data.ecommerce.supplies",
              "macro.dbt_utils.surrogate_key"
            ]
          }
        ],
        "parentsSources": [
          {
            "name": "customers",
            "uniqueId": "source.demo_data.ecommerce.customers"
          },
          {
            "name": "locations",
            "uniqueId": "source.demo_data.ecommerce.locations"
          },
          {
            "name": "order_items",
            "uniqueId": "source.demo_data.ecommerce.order_items"
          },
          {
            "name": "orders",
            "uniqueId": "source.demo_data.ecommerce.orders"
          },
          {
            "name": "products",
            "uniqueId": "source.demo_data.ecommerce.products"
          },
          {
            "name": "supplies",
            "uniqueId": "source.demo_data.ecommerce.supplies"
          }
        ]
      },
      {
        "name": "orders",
        "uniqueId": "model.demo_data.orders",
        "dependsOn": [
          "model.demo_data.stg_orders",
          "model.demo_data.stg_order_items",
          "model.demo_data.stg_products",
          "model.demo_data.stg_locations",
          "model.demo_data.stg_supplies"
        ],
        "parentsModels": [
          {
            "name": "stg_locations",
            "uniqueId": "model.demo_data.stg_locations",
            "dependsOn": [
              "source.demo_data.ecommerce.locations",
              "macro.dbt_utils.current_timestamp"
            ]
          },
          {
            "name": "stg_order_items",
            "uniqueId": "model.demo_data.stg_order_items",
            "dependsOn": [
              "source.demo_data.ecommerce.order_items"
            ]
          },
          {
            "name": "stg_orders",
            "uniqueId": "model.demo_data.stg_orders",
            "dependsOn": [
              "source.demo_data.ecommerce.orders",
              "macro.dbt_utils.current_timestamp"
            ]
          },
          {
            "name": "stg_products",
            "uniqueId": "model.demo_data.stg_products",
            "dependsOn": [
              "source.demo_data.ecommerce.products"
            ]
          },
          {
            "name": "stg_supplies",
            "uniqueId": "model.demo_data.stg_supplies",
            "dependsOn": [
              "source.demo_data.ecommerce.supplies",
              "macro.dbt_utils.surrogate_key"
            ]
          }
        ],
        "parentsSources": [
          {
            "name": "locations",
            "uniqueId": "source.demo_data.ecommerce.locations"
          },
          {
            "name": "order_items",
            "uniqueId": "source.demo_data.ecommerce.order_items"
          },
          {
            "name": "orders",
            "uniqueId": "source.demo_data.ecommerce.orders"
          },
          {
            "name": "products",
            "uniqueId": "source.demo_data.ecommerce.products"
          },
          {
            "name": "supplies",
            "uniqueId": "source.demo_data.ecommerce.supplies"
          }
        ]
      },
      {
        "name": "stg_customers",
        "uniqueId": "model.demo_data.stg_customers",
        "dependsOn": [
          "source.demo_data.ecommerce.customers"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "customers",
            "uniqueId": "source.demo_data.ecommerce.customers"
          }
        ]
      },
      {
        "name": "stg_locations",
        "uniqueId": "model.demo_data.stg_locations",
        "dependsOn": [
          "source.demo_data.ecommerce.locations",
          "macro.dbt_utils.current_timestamp"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "locations",
            "uniqueId": "source.demo_data.ecommerce.locations"
          }
        ]
      },
      {
        "name": "stg_order_items",
        "uniqueId": "model.demo_data.stg_order_items",
        "dependsOn": [
          "source.demo_data.ecommerce.order_items"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "order_items",
            "uniqueId": "source.demo_data.ecommerce.order_items"
          }
        ]
      },
      {
        "name": "stg_orders",
        "uniqueId": "model.demo_data.stg_orders",
        "dependsOn": [
          "source.demo_data.ecommerce.orders",
          "macro.dbt_utils.current_timestamp"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "orders",
            "uniqueId": "source.demo_data.ecommerce.orders"
          }
        ]
      },
      {
        "name": "stg_products",
        "uniqueId": "model.demo_data.stg_products",
        "dependsOn": [
          "source.demo_data.ecommerce.products"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "products",
            "uniqueId": "source.demo_data.ecommerce.products"
          }
        ]
      },
      {
        "name": "stg_supplies",
        "uniqueId": "model.demo_data.stg_supplies",
        "dependsOn": [
          "source.demo_data.ecommerce.supplies",
          "macro.dbt_utils.surrogate_key"
        ],
        "parentsModels": [],
        "parentsSources": [
          {
            "name": "supplies",
            "uniqueId": "source.demo_data.ecommerce.supplies"
          }
        ]
      },
      {
        "name": "dbt_metrics_default_calendar",
        "uniqueId": "model.metrics.dbt_metrics_default_calendar",
        "dependsOn": [
          "macro.metrics.metric_date_spine",
          "macro.dbt.date_trunc"
        ],
        "parentsModels": [],
        "parentsSources": []
      }
    ],
    "metrics": [
      {
        "name": "customers",
        "uniqueId": "metric.demo_data.customers",
        "dependsOn": [
          "model.demo_data.orders"
        ],
        "model": {
          "name": "orders",
          "uniqueId": "model.demo_data.orders",
          "dependsOn": [
            "model.demo_data.stg_orders",
            "model.demo_data.stg_order_items",
            "model.demo_data.stg_products",
            "model.demo_data.stg_locations",
            "model.demo_data.stg_supplies"
          ]
        }
      },
      {
        "name": "expenses",
        "uniqueId": "metric.demo_data.expenses",
        "dependsOn": [
          "model.demo_data.orders"
        ],
        "model": {
          "name": "orders",
          "uniqueId": "model.demo_data.orders",
          "dependsOn": [
            "model.demo_data.stg_orders",
            "model.demo_data.stg_order_items",
            "model.demo_data.stg_products",
            "model.demo_data.stg_locations",
            "model.demo_data.stg_supplies"
          ]
        }
      },
      {
        "name": "gross_profit",
        "uniqueId": "metric.demo_data.gross_profit",
        "dependsOn": [
          "metric.demo_data.revenue",
          "metric.demo_data.expenses"
        ],
        "model": null
      },
      {
        "name": "revenue",
        "uniqueId": "metric.demo_data.revenue",
        "dependsOn": [
          "model.demo_data.orders"
        ],
        "model": {
          "name": "orders",
          "uniqueId": "model.demo_data.orders",
          "dependsOn": [
            "model.demo_data.stg_orders",
            "model.demo_data.stg_order_items",
            "model.demo_data.stg_products",
            "model.demo_data.stg_locations",
            "model.demo_data.stg_supplies"
          ]
        }
      }
    ]
```
</TabItem>
</Tabs>

## Quality

Information from dbt runs helps data teams monitor quality and data consumers know that they’re using fresh and accurate data for their analyses, mitigating the risk of people making the wrong decisions based on outdated or incorrect data.  

The Metadata API provides information to monitor the health of the dbt DAG and its data sources to ensure quality. The API can be used for diagnostics, detecting and investigating issues, or proactive alerting when coupled with features like [webhooks](/docs/deploy/webhooks).

Quality information is useful in analytics and monitoring tools.

<Lightbox src="/img/docs/dbt-cloud/metadata-api/data-freshness-metadata.jpg" title="Quality and freshness dashboard status tile defined via exposures"/>


### Tests

Data teams use the Metadata API to understand existing [test](https://docs.getdbt.com/docs/build/tests) coverage and identify, diagnose, and resolve issues. For instance, looking at the percentage of runs with test failures or which tests commonly fail over time to supplement job-level alerting and the stored_test_failures feature. Test information is also helpful for data consumers, who could view the test statuses in their integrated analytics tools and trust that they’re looking at valid, vetted data. 

Test failures could indicate degraded data quality. In this example query, one of the tests failed, so the user should examine upstream dependencies to ensure the data are valid and fix the issue from there.

<Tabs>

<TabItem value="querytests" label="Example query">

```
tests(jobId: $jobId) {
    name
    skip
    state
    resourceType
    fail
    error
	columnName
    dependsOn
 }
 ```
 </TabItem>

 <TabItem value="responsetests" label="Example response">

```
{
        "name": "not_null_orders_order_id",
        "skip": false,
        "state": "ERROR",
        "resourceType": "test",
        "fail": true,
        "error": "Ensure orders are properly entered.",
        "columnName": "order_id",
        "dependsOn": [
          "model.demo_data.orders",
          "macro.dbt.test_not_null",
          "macro.dbt.get_where_subquery"
        ]
      },
{
        "name": "relationships_orders_customer_id__customer_id__ref_stg_customers_",
        "skip": false,
        "state": "pass",
        "resourceType": "test",
        "fail": false,
        "error": null,
        "columnName": "customer_id",
        "dependsOn": [
          "model.demo_data.stg_customers",
          "model.demo_data.orders",
          "macro.dbt.test_relationships",
          "macro.dbt.get_where_subquery"
        ]
      },
{
        "name": "unique_customers_customer_id",
        "skip": false,
        "state": "pass",
        "resourceType": "test",
        "fail": false,
        "error": null,
        "columnName": "customer_id",
        "dependsOn": [
          "model.demo_data.customers",
          "macro.dbt.test_unique",
          "macro.dbt.get_where_subquery"
        ]
      }
 ```
 </TabItem>
 </Tabs>

 ### Source freshness

Monitoring source [freshness](/docs/build/sources#snapshotting-source-data-freshness) helps users ensure that the datasets used are not stale. Like test failures, stale data indicate that there may be a problem with the data pipeline. Data teams can check load time and freshness state then diagnose and resolve pipeline issues to ensure the most up-to-date data reaches consumers. Data consumers may view freshness information in their integrated analytics tools to help ensure they’re drawing the right conclusions from the data.

*Note: To monitor adherence with freshness SLAs, pull from a job with [source freshness](/docs/deploy/source-freshness) enabled.*

<Tabs>

<TabItem value="queryfreshness" label="Example query">

```
source(jobId: $jobId, uniqueId: $uniqueId) {
    name
    description
    uniqueId
    type
    database
    freshnessChecked
    state
    identifier
    loader
    snapshottedAt
    maxLoadedAt
    stats {
      label
      description
      value
    }
}
 ```
 </TabItem>

 <TabItem value="responsefreshness" label="Example response">

```
"source": {
      "name": "customers",
      "description": "One record per person who has purchased one or more items",
      "uniqueId": "source.demo_data.ecommerce.customers",
      "type": "EXTERNAL TABLE",
      "database": "DBT_DEMO_DATA",
      "freshnessChecked": false,
      "state": "pass",
      "identifier": "customers",
      "loader": "manual",
      "snapshottedAt": "2022-12-03T10:15:30Z",
      "maxLoadedAt": "2022-12-04T07:31:28Z",
      "stats": [
        {
          "label": "Approximate Size",
          "description": "Approximate size of the table as reported by Snowflake",
          "value": 132733
        }
      ]
    }
 ```
 </TabItem>
 </Tabs>

 ### Dataset Statistics

The Metadata API can be used to retrieve statistics about the dataset’s statistics, like row count, column count, null values, and last updated. API users like data quality tools can run checks to make sure the dataset conforms to expectations and is in good shape to be used. This is especially valuable when such metadata aren’t provided by the data platform. Tools can supplement this information with properties like model owner and metadata tags to provide more context and frame analyses.

<Tabs>

<TabItem value="querydataset" label="Example query">

```
model(jobId: $jobId, uniqueId: $uniqueId) {
    database
    schema
    name
    status
    executeCompletedAt
    executionTime
    stats {
      id
      label
      description
      include
      value
    }
  }
 ```
 </TabItem>

 <TabItem value="responsedataset" label="Example response">

```
"model": {
      "database": "analytics",
      "schema": "semantic_layer_demo",
      "name": "customers",
      "status": "success",
      "executeCompletedAt": "2023-03-06T17:02:01.216Z",
      "executionTime": 3.737823247909546,
      "stats": [
        {
          "id": "bytes",
          "label": "Approximate Size",
          "description": "Approximate size of the table as reported by Snowflake",
          "include": true,
          "value": 184832
        },
        {
          "id": "last_modified",
          "label": "Last Modified",
          "description": "The timestamp for last update/change",
          "include": true,
          "value": "2023-03-06 17:02UTC"
        },
        {
          "id": "row_count",
          "label": "Row Count",
          "description": "An approximate count of rows in this table",
          "include": true,
          "value": 2702
        },
        {
          "id": "has_stats",
          "label": "Has Stats?",
          "description": "Indicates whether there are statistics for this table",
          "include": false,
          "value": true
        }
      ]
    }
 ```
 </TabItem>
 </Tabs>

 ## Operations

Operations are at the core of dbt Cloud. Understanding how dbt is executed helps inform both project development and orchestration setup. By gaining insights into the system's health with observability, data teams can ****run dbt efficiently and effectively to reduce infrastructure and time costs incurred by the organization. The Model Timing image below is an example of the “Model Builds” use case powered by the Metadata API, which many customers use to identify and improve model bottlenecks.

<Lightbox src="/img/docs/dbt-cloud/metadata-api/model-timing.jpg" title="Model timing visualization in dbt Cloud"/>

### Run Performance

The Metadata API enables users to analyze higher-level statistics like run count and success rate to monitor deployment activity. The data team might use these results to understand the usage of dbt Cloud and identify any issues that lead to run failures and thus incomplete or outdated data. Users can query up to the past 10 runs for a given environment to analyze trends in run statistics.

<Tabs>

<TabItem value="queryperformance" label="Example query">

```
modelByEnvironment(environmentId: $environmentId, uniqueId: $uniqueId, lastRunCount: $lastRunCount) {
    uniqueId
    status
    database
    schema
    name
    resourceType
    type
    materializedType
    tests{
      columnName
      error
      fail
      status
    }
    runResults {
      executionTime
      runGeneratedAt
      runElapsedTime
      error
      status
      skip
      compileStartedAt
      compileCompletedAt
      executeStartedAt
      executeCompletedAt
    }  
  }
}
 ```
 </TabItem>

 <TabItem value="responseperformance" label="Example response">

```
"modelByEnvironment": [
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "database": "analytics",
        "schema": "semantic_layer_demo",
        "name": "customers",
        "resourceType": "model",
        "type": "BASE TABLE",
        "materializedType": "table",
        "tests": [
          {
            "columnName": "customer_type",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          }
        ],
        "runResults": [
          {
            "executionTime": 3.737823247909546,
            "runGeneratedAt": "2023-03-06T17:02:02.713Z",
            "runElapsedTime": 72.83101916313171,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-03-06T17:01:57.656Z",
            "compileCompletedAt": "2023-03-06T17:01:57.662Z",
            "executeStartedAt": "2023-03-06T17:01:57.662Z",
            "executeCompletedAt": "2023-03-06T17:02:01.216Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "database": "analytics",
        "schema": "semantic_layer_demo",
        "name": "customers",
        "resourceType": "model",
        "type": "BASE TABLE",
        "materializedType": "table",
        "tests": [
          {
            "columnName": "customer_type",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          }
        ],
        "runResults": [
          {
            "executionTime": 2.966937780380249,
            "runGeneratedAt": "2023-03-06T16:02:31.295Z",
            "runElapsedTime": 73.83759474754333,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-03-06T16:02:27.002Z",
            "compileCompletedAt": "2023-03-06T16:02:27.007Z",
            "executeStartedAt": "2023-03-06T16:02:27.007Z",
            "executeCompletedAt": "2023-03-06T16:02:29.710Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "database": "analytics",
        "schema": "semantic_layer_demo",
        "name": "customers",
        "resourceType": "model",
        "type": "BASE TABLE",
        "materializedType": "table",
        "tests": [
          {
            "columnName": "customer_type",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          }
        ],
        "runResults": [
          {
            "executionTime": 3.0948281288146973,
            "runGeneratedAt": "2023-03-06T15:02:20.175Z",
            "runElapsedTime": 73.74312734603882,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-03-06T15:02:15.719Z",
            "compileCompletedAt": "2023-03-06T15:02:15.727Z",
            "executeStartedAt": "2023-03-06T15:02:15.727Z",
            "executeCompletedAt": "2023-03-06T15:02:18.622Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "database": "analytics",
        "schema": "semantic_layer_demo",
        "name": "customers",
        "resourceType": "model",
        "type": "BASE TABLE",
        "materializedType": "table",
        "tests": [
          {
            "columnName": "customer_type",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          }
        ],
        "runResults": [
          {
            "executionTime": 3.014812469482422,
            "runGeneratedAt": "2023-03-06T14:01:58.360Z",
            "runElapsedTime": 71.57624459266663,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-03-06T14:01:53.994Z",
            "compileCompletedAt": "2023-03-06T14:01:54.000Z",
            "executeStartedAt": "2023-03-06T14:01:54.000Z",
            "executeCompletedAt": "2023-03-06T14:01:56.809Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "database": "analytics",
        "schema": "semantic_layer_demo",
        "name": "customers",
        "resourceType": "model",
        "type": "BASE TABLE",
        "materializedType": "table",
        "tests": [
          {
            "columnName": "customer_type",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          },
          {
            "columnName": "customer_id",
            "error": null,
            "fail": false,
            "status": "pass"
          }
        ],
        "runResults": [
          {
            "executionTime": 3.4301769733428955,
            "runGeneratedAt": "2023-03-06T13:02:16.868Z",
            "runElapsedTime": 72.33108758926392,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-03-06T13:02:11.908Z",
            "compileCompletedAt": "2023-03-06T13:02:11.913Z",
            "executeStartedAt": "2023-03-06T13:02:11.914Z",
            "executeCompletedAt": "2023-03-06T13:02:15.145Z"
          }
        ]
      }
    ]
 ```
 </TabItem>
 </Tabs>

 ### Model builds

Analyzing model build times helps users identify bottlenecks to optimize code and orchestration settings, ultimately reducing costs and speeding up time to fresh data. The data team may use this information to identify models that need to be broken up or have their code improved in order to reduce data platform query consumption and conform with freshness SLAs for downstream consumers. They may also look at changing how the orchestration is scheduled to run slower models less frequently and avoid bottlenecks.

<Tabs>

<TabItem value="querybuilds" label="Example query">

```
{
  modelByEnvironment(environmentId: $environmentId, uniqueId: $uniqueId, lastRunCount: $lastRunCount) {
    uniqueId
    status
    runResults {
      executionTime
      runGeneratedAt
      runElapsedTime
      error
      status
      skip
      compileStartedAt
      compileCompletedAt
      executeStartedAt
      executeCompletedAt
    }  
  }
 ```
 </TabItem>

 <TabItem value="responsebuilds" label="Example response">

```
"modelByEnvironment": [
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "runResults": [
          {
            "executionTime": 2.692153215408325,
            "runGeneratedAt": "2023-02-27T02:01:55.593Z",
            "runElapsedTime": 76.84831595420837,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-02-27T02:01:51.210Z",
            "compileCompletedAt": "2023-02-27T02:01:51.216Z",
            "executeStartedAt": "2023-02-27T02:01:51.216Z",
            "executeCompletedAt": "2023-02-27T02:01:53.723Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "runResults": [
          {
            "executionTime": 3.1301932334899902,
            "runGeneratedAt": "2023-02-27T01:02:22.586Z",
            "runElapsedTime": 71.21909546852112,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-02-27T01:02:18.012Z",
            "compileCompletedAt": "2023-02-27T01:02:18.017Z",
            "executeStartedAt": "2023-02-27T01:02:18.017Z",
            "executeCompletedAt": "2023-02-27T01:02:20.935Z"
          }
        ]
      },
      {
        "uniqueId": "model.demo_data.customers",
        "status": "success",
        "runResults": [
          {
            "executionTime": 3.045269250869751,
            "runGeneratedAt": "2023-02-27T00:02:31.981Z",
            "runElapsedTime": 72.81425666809082,
            "error": null,
            "status": "success",
            "skip": false,
            "compileStartedAt": "2023-02-27T00:02:27.267Z",
            "compileCompletedAt": "2023-02-27T00:02:27.275Z",
            "executeStartedAt": "2023-02-27T00:02:27.275Z",
            "executeCompletedAt": "2023-02-27T00:02:30.073Z"
          }
        ]
      }
    ]
 ```
 </TabItem>
 </Tabs>

 ## Related docs

 - [Metadata API product roadmap]
 - [Query Metadata API]
 - [dbt Semantic Layer integration guide]